# 10. 클래스
- 클래스는 작아야 함
- 응집도가 높게, 결합도는 낮게
- 클래스를 잘 분리(단순)했을 때 장점
  - 코드 이해가 잘 됨
  - 함수 하나를 수정했을 때 다른 함수가 망가질 가능성 제거 가능
  - 테스트 관점에서 논리를 나눴기 때문에 증명하기 쉬움
  - 함수를 추가할 때 기존 클래스 수정할 필요 없음
  - SRP, OCP를 지원하여, 새 기능 추가나 제거가 쉬움
- 시스템 결합도를 낮췄을 때 장점
  - 유연성과 재사용성도 더욱 높아짐
  - 시스템 요소가 잘 격리되어 있고, 각 요소를 이해하기도 더 쉬움
  - 테스트가 쉬워짐

# 11. 시스템
- 시스템은 깨끗해야 함
  - 깨끗하지 못한 아키텍쳐 → 도메인 논리 흐림 & 기민성 하락 → 제품 품질 & 생산성 하락
- 적절한 추상화와 모듈화가 중요함
- 모든 추상화 단계에서 의도는 명확히 표현하기
- 각 구현 관심사를 분리해야 함 ("관심사 분리" 설계 기법)

# 12. 창발성
- 창발성
  - 하위 계층 (구성 요소)에는 없는 특성이나 행동이 상위 계층 (전체 구조) 에서 자발적으로 돌연히 출현하는 현상
  - emergent property 또는 emergence (불시에 솟아나는 특성)
  - 각 흰개미는 집을 지을 지능은 없지만, 그 집합체는 역할이 서로 다른 개미들의 상호작용을 통해 거대한 탑을 만듦
- 단순한 설계 규칙 4가지 - 켄트 벡 (중요도 순)
  - 모든 테스트를 실행한다.
  - 중복을 없앤다.
  - 프로그래머 의도를 표현한다.
  - 클래스와 메서드 수를 최소로 줄인다.

# 13. 동시성
- 다중 스레드 코드는 올바로 구현하기 어렵기 때문에 각별히 깨끗하게 코드를 짜야 함
- 무엇보다 먼저, SRP 준수하기!
- 스레드를 아는 코드와 스레드를 모르는 코드를 분리하기
  - POJO를 사용하기
- 스레드 코드를 테스트할 때는 전적으로 스레드만 테스트하기
- 동시성 오류를 일으키는 잠정적 원인을 철저히 이해하기
- 어떻게든 문제는 생김, 일회성 문제로 인식하고 무시하면 안 됨
- 공유하는 객체 수와 범위를 최대한 줄이기
- 스레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트해야 함

# 14. 점진적인 개선
- 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 한다는 의미
- 일단 프로그램이 ‘돌아가면’ 다음 업무로 넘어가는 행위는 ‘전문가로서 자살 행위’
- 한 번에 하나씩 고치면서 테스트를 계속 돌림
  - 테스트 케이스가 하나라도 실패하면 다음 변경으로 넘어가기 전에 오류를 수정함
- 소프트웨어 설계는 분할만 잘해도 품질이 크게 높아짐. 적절한 장소를 만들어 코드만 분리해도 설계가 좋아짐. 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워짐 
- 나쁜 코드보다 더 오랫동안 더 심각하게 개발 프로젝트에 악영향을 미치는 요인도 없음
  
[느낀 점]
Java와 관련된 얘기가 많았음 (정리하다가 포기하게 되는...)
클래스/메소드 크기 작아야 하고, 단일 책임(SRP), 명칭 잘 지어야 함 (간결한 이름이 나오지 않으면 크기가 큰 것임)
코드는 언제나 최대한 깔끔하고 단순하게 정리하자
나쁜 코드는 빠르게 개선하자
JS에서 multi thread를 쓸 때 조심하고 신경을 많이 쓰자 (Web worker)
