# 14. 점진적인 개선

## Args 구현

### 어떻게 짰느냐고?

- 깨끗한 코드를 짜려면 먼저 지저분한코드를 짠 뒤에 정리해야 한다는 의미
- 일단 프로그램이 ‘돌아가면’ 다음 업무로 넘어가는 행위는 ‘전문가로서 자살 행위’

## **Args: 1차 초안**

- 지저분한 코드에 기여하는 요인 : ‘TILT’와 같은 희한한 문자열, try-catch-catch 블록 등
- 기능이 추가되고 코드를 수정하면서, 점차 통제를 벗어나게 됨

### 그래서 멈췄다

- Args 초안에 기능을 추가하지 않기로 결정하고 리팩터링을 시작함

### **점진적으로 개선하다**

- 프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위
    - '개선' 전과 똑같이 프로그램을 돌리기가 아주 어렵기 때문
- 따라서, 테스트 주도 개발(Test-Driven Development, TDD)을 사용함
    - TDD는 언제 어느 때라도 시스템이 돌아가야 한다는 원칙을 따름
    - 즉, TDD는 시스템을 망가뜨리는 변경을 허용하지 않음
    - 변경을 가한 후에도 시스템 이 변경 전과 똑같이 돌아가야 함
- 변경 전후에 시스템이 똑같이 돌아간다는 사실을 확인하려면 언제든 실행이 가능한 자동화된 테스트 슈트가 필요함
- 단위 테스트슈트와 인수테스트를 만들어 놓고 자잘하게 수정함
    - 두 테스트 모두 언제든 실행이 가능했으며, 시스템이 두 테스트를 모두 통과하면 올바로 동작한다고 봄
    - e.g. 단위 테스트 슈트는 JUnit 프레임워크에서 자바로 작성하고, 인수 테스트는 FitNess에서 위키 페이지로 작성함

## **String 인수**

- 한 번에 하나씩 고치면서 테스트를 계속 돌림
- 테스트 케이스가 하나라도 실패하면 다음 변경으로 넘어가기 전에 오류를 수정함
- 리팩터링을 하다 보면 코드를 넣었다 뺐다 하는 사례가 아주 흔함
- 소프트웨어 설계는 분할만 잘해도 품질이 크게 높아지고
- 적절한 장소를 만들어 코드만 분리해도 설계가 좋아진
- 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워짐

## 결론

- 그저 돌아가는 코드만으로는 부족함 (돌아가는 코드가 심하게 망가지는 사례는 흔함)
- 단순히 돌아가는 코드에 만족하는 프로그래머는 전문가 정신이 부족함
- 나쁜 코드보다 더 오랫동안 더 심각하게 개발 프로젝트에 악영향을 미치는 요인도 없음
    - 나쁜 일정은 다시 짜면 됨
    - 나쁜 요구사항은 다시 정의하면 됨
    - 나쁜 팀 역학은 복구하면 됨
    - 하지만, 나쁜 코드는 썩어 문드러진다! →
- 나쁜 코드 개선은 비용이 엄청 많이 발생함. 반면, 처음부터 코드를 깨끗하게 유지하기란 상대적으로 쉬움
    - 아침에 엉망으로 만든 코드를 오후에 정리하기는 어렵지 않고, 5분 전에 엉망으로 만든 코드는 지금 당장 정리하기 아주 쉬움
- 코드는 언제나 최대한 깔끔하고 단순하게 정리하자