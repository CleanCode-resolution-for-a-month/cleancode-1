# 11. 시스템

## 도시를 세운다면?

- 한 사람의 힘으로 도시를 관리하기 힘들다
- 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워짐
- 적절한 추상화와 모듈화가 중요함

## 시스템 제작과 시스템 사용을 분리하라

- 제작 (construction) 과 사용(use)는 다름
- 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 연결하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 함
- “관심사 분리”는 중요한 설계 기법 중 하나
- ‘시작 단계’ 라는 관심사를 분리하지 않은 예시 (Lazy Initialization)
    
    ```tsx
    const getService = (): Service => {
    	if (service === null) 
    		service = new Service(); // 모든 상황에 적합한 기본값일까?
    	return service;
    }
    ```
    
    - getService가 Service에 의존하고 있기 때문에, 테스트할 때 적절한 Service 객체를 service 필드에 할당해야 하는데 무거운 객체 일 수 있고 null인 경우와 아닌 경우 모두 테스트 해야 함
    (또한, Java 같은 컴파일 언어에서는 의존성을 해결하지 않으면 컴파일이 안 됨)
    - 책임이 2개 이상 → 단일 책임의 원칙을 깸
- 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아짐

### Main 분리

… 자바 관련된 내용으로 가득하여 정리 포기…

## 순수 자바 AOP 프레임워크

- ‘순수 자바’란 AspectJ를 쓰지 않는 다는 뜻
- 순수 자바 관점을 구현하는 AOP 프레임워크 : 스프링, JBoss
- 스프링은 비즈니스 논리를 POJO로 구현함 → POJO는 순수하게 도메인에 초점을 마춤 & POJO는 enterprise 프레임워크에 의존하지 않음 → 테스트가 개념적으로 쉽고 간단함 → 구현하기 쉬우며 코드를 보수하고 개선하기 편함
- 프레임워크는 사용자가 모르게 영속성, 트랜잭션, 보안, 캐스 등 횡단 관심사를 프록시나 바이너리 라이브러리를 사용하여 구현함

## AspectJ 관점

- 관심사를 관점으로 분리하는 가장 강력한 도구는 AspectJ언어
- AspectJ : 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장

## 테스트 주도 시스템 아키텍처 구축

- 최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화된 관심사 영역 (도메인)으로 구성됨
- 진정한 ‘테스트 주도’ 아키텍처 구축 가능함
- 필요할 때, (새로운 기술이나 도구 등을 이용해) 단순한 아키텍처를 복잡한 아키텍처로 확장 가능
    - 세계 최대 웹 사이트들은 고도의 자료 캐싱, 보안, 가상화 등을 이용해 높은 가용성과 성능을 효율적이고도 유연하게 달성함
    - 설계가 최대한 분리되어 각 추상화 수준과 범위에서 코드가 적당히 단순하기 때문임
- BDUF를 추구하지 않을 수 있음
    - Big Design Up Front : 앞으로 벌어질 모든 사항을 설계하는 기법 (≠선행 설계)

## 의사 결정을 최적화 하라

- 가장 적합한 사람에게 책임을 맡기면 좋다
- 때때로 가능한 마지막 순간까지 결정을 미루는 방법이 최선이기도 함
    - 정보를 충분히 모아 최선의 결정을 내림
    - 고객의 피드백을 더 모으고, 프로젝트를 더 고민하고, 구현 방안을 더 탐험할 기회
- 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공함
- 기민함 덕분에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기 쉽고, 결정의 복잡성도 줄어듦

## 명백한 가치가 있을 때 표준을 현명하게 사용하라

- 저자는 아주 과장되게 포장된 표준에 집착하는 바람에 고객 가치가 뒷전으로 밀려난 사례를 많이 봐왔음
- 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고, 컴포넌트를 엮기 쉽다. 하지만, 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 제정한 목적을 잊어버리기도 한다.

## 시스템은 도메인 특화 언어가 필요하다

- DSL (Domain-Specific Language) : 간단한 스크립트 언어나 표준 언어로 구현한 API
- 좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 ‘의사소통 간극’을 줄여줌
    - 애자일 기법은 팀과 프로젝트 이해관계자 사이에 의사소통 간극을 줄여주듯이..
    - 도메인 전문가가 사용하는 언어로 도메인 논리를 구현하면 도메인을 잘못 구현할 가능성이 줄어듦
- DSL을 사용하면 고차원 정책에서 저차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현 가능

## 결론

- 시스템은 깨끗해야 함
    - 깨끗하지 못한 아키텍쳐 → 도메인 논리 흐림 & 기민성 하락→ 제품 품질 & 생산성 하락
- 모든 추상화 단계에서 의도는 명확히 표현하기
- POJO를 작성하고 관점 혹은 관점과 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야 함
