# 5. 형식 맞추기

- 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야함
- 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 함
- 필요하다면 규칙을 자동으로 적용하는 도구를 활용하기

## 형식을 맞추는 목적

- 코드의 형식이 중요함
- 코드 형식은 의사소통의 일환
    - 의사소통은 전문 개발자의 일차적인 의무임
- 코드는 사라질지라도 개발자의 스타일과 규율은 사라지지 않음
    - 오랜 시간이 지나 원래 코드가 다 바뀌어도 맨 처음 잡아놓은 구현 스타일과 가성 수준은 유지보수 용이성과 확장성에 계속 영향을 미침
- 원활한 소통을 장려하는 코드 형식이란??

## 적절한 행 길이를 유지하라

- 일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다
    - 작은 파일만으로도 큰 시스템을 구출할 수 있음

### 신문 기사처럼 작성하라

- 이름은 간단하면서도 설명이 가능하게 짓기
- 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명함
- 아래로 내려갈수록 의도를 세세하게 묘사함
- 마지막에는 가장 저차원 함수와 세부 내역이 나옴
- 신문의 대다수 기사는 아주 짧음

### 개념은 빈 행으로 분리하라

- 빈 행은 새로운 개념을 시작한다는 시각적인 단서 (개념 분리)

### 세로 밀집도

- 세로 밀집도는 연관성을 의미함
- 서로 밀접한 코드 행은 세로로 가까이 놓여야 함

### 수직 거리

- 서로 밀접한 개념은 한 파일에 속해야 마땅함 → protected 변수를 피해야 하는 이유
- 변수는 사용하는 위치에 최대한 가까이 선언하기
- 지역 변수는 각 함수 맨 처음에 선언하기
- 잘 알려진 위치에 인스턴스 변수를 모으기
    - 인스턴스 변수는 클래스 맨 처음에 선언하기. 잘 설계한 클래스는 대다수의 클래스 메서드가 인스턴스 변수를 사용하기 때문
    - C++ : 가위 규칙을 적용하여 클래스 마지막에 선언함
    
    ```jsx
    class Person {
    	// 인스턴스 변수 
      #id: number;
    	name: string;
      
      constructor(id: number, name: string) {
        this.#id = id;
        this.name = name;
      }
    
    	// 인스턴스 메서드
      getId() {
        return this.#id;
      }
    
      getName() {
        return this.name;
      }
      
    	// 클래스 메서드
      static sayHello() {
        console.log('hello');
      }
    }
    
    const tom = new Person(1, 'tom');
    tom.getId(); // 1
    tom.#id; // Uncaught SyntaxError: Private field '#id' must be declared in an enclosing class
    tom.name; // 'tom'
    tom.getName(); // 'tom'
    tom.name = 'emma';
    tom.getName(); // 'emma'
    tom.sayHello(); // Uncaught TypeError: tom.sayHello is not a function
    Person.sayHello(); // 'hello'
    ```
    
- 종속 함수
    - 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치하고, 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치하기
        - JS 에서 화살표 함수를 쓰는 경우는 호출 함수 위에 배치해야 함
    - 상수를 알아야 마땅한 함수에서 실제로 사용하는 함수로 상수를 넘겨주는 방법이 더 좋음
        - 잘 알려진 상수가 적절하지 않은 저차원 함수에 묻히는 상황을 피할 수 있음
        
        ```jsx
        getPageNameOrDetail(request, 'FrontPage');
        function getPageNameOrDetail(req, defaultPageName) {
        	let pageName = req?.body?.pagename;
        	if (!pageName) pageName = defaultPageName;
        	return pageName;
        }
        ```
        
- 개념적 유사성
    - 개념적으로 친화도가 높을 수록 가까이 배치
    - 친화도가 높은 요인
        - 종속성 : 변수와 그 변수를 사용하는 함수
        - 비슷한 동작을 수행하는 함수들
            - 명명법이 똑같고 기본 기능이 유사하고 간단함
            - 부차적인 요인으로 서로가 서로를 호출하기도 함

### 세로 순서

- 일반적으로 함수 호출 종속성은 아래 방향으로 유지
- 함수를 호출하는 함수를 위에 배치
    - 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려감
    - 중요한 내용이 먼저 나올 수 있음

## 가로 형식 맞추기

- 프로그래머는 명백하게 짧은 행을 선호함
- 80자 이후부터 행 수는 급격히 감소함
- 80자 제한은 다소 인위적이고, 100~120자도 나쁘지 않음. 그 이상은 주의부족임

> Prettier - Print Width 의 default는 80
> 

### 가로 공백과 밀집도

- 가로 공백을 사용해 밀접한 개념과 느슨한 개념을 표현 가능
- 할당 연산자 앞 뒤엔 공백 주어 두 요소가 확실히 나뉜다는 것을 분명히 함 `a += b;`
- 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않음 `add(a,b);`
- 그 외에…
    - `new Point(a, b, c);` 콤마 다음 공백
    - `b*b - 4*a*c;`

### 가로 정렬

- 가로 정렬은 유용하지 못함
    - 엉뚱한 부분을 강조해 진짜 의도를 가림
    - 변수 유형은 무시하고 변수 이름부터 읽게 됨
    - 할당 연산자는 보이지 않고 오른쪽 피연산자에 눈이 감
- 선언문과 할당문을 별도로 정렬하지 않음
- 정렬이 필요할 정도로 목록이 길다면 문제는 목록 길이임 (정렬이 아님) → 클래스를 나눠야 함

### 들여쓰기

- 범위 (scope)로 이뤄진 계층을 표현하기 위해 코드를 들여씀
- 들여쓰기한 파일은 구조가 한눈에 들어옴 (가독성 좋음)
- 들여쓰기 무시하기 .. 하지 말아라!

### 가짜 범위

- 빈 while 문이나 for문
    
    ```jsx
    while (dis.read(buf, 0, readBufferSize) != -1)
    ;
    ```
    
- 이런 코드는 눈에 띄지 않아 골탕을 먹을 수 있음! 쓰지 않기!

## 팀 규칙

- 소프트웨어가 일관적인 스타일을 보이기 위해서 팀 내 합의한 한 가지 규칙을 따르기
- 어디에 괄호를 넣을지, 들여쓰기는 몇자로 할지, 클래스와 변수와 메서드 이름은 어떻게 지을지 등

## 밥 아저씨의 형식 규칙

- 책에 나온 예시는 자바로, 코드 자체가 최고의 구현 표준 문서가 되는 예라고 함..
