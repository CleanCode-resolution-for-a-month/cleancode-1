# 15. JUnit 들여다보기

## JUnit 프레임워크

- 중복되는 정보를 가진 접두어 제거
    - 오늘날 개발 환경에서는 변수 이름에 범위를 명시하지 않아도 됨
- 조건문을 메서드로 뽑아내 적절한 이름을 붙이기 (캡슐화)
- 이름은 명확하고 적절(적합)하게 붙이기
- 첫 문장 if를 긍정으로 만들기 (부정문은 긍정문보다 이해하기 약간 더 어려움)
- 함수를 분리하기
- 숨겨진 시간적인 결합 (hidden temporal coupling)이 있는 경우, 의존하는 값을 인자로 받아 처리 가능. 하지만, 다소 자의적이고 인자의 필요성이 타당하지 않아 보일 수 있음 → 함수를 분리하여 호출 순서를 명확하게 만들 수 있음
- 리팩터링은 코드가 어느 수준에 이를 때까지 수많은 시행착오를 반복하는 작업이기 때문에, 원래 했던 변경을 되돌리는 경우가 흔함

## 결론

- 코드를 처음보다 조금 더 깨끗하게 만드는 책임은 우리 모두에게 있음 (보이스카우트 규칙)

# 16. SerialDate 리팩터링

- JCommon 라이브러리에 `[org.jfree.date](http://org.jfree.date)` 패키지에 SerialDate 클래스 (David Gilbert)
- 순수 날짜 클래스

## 첫째, 돌려보자

- 코드 커버리지 분석 도구인 Clover를 이용하면 대략 50% 정도가 나옴
    - 단위 테스트가 실행되지 않은 코드가 클래스 내에 많음
    - 실패한 테스트 케이스가 주석 처리되어 있는 경우도 많음 (마땅히 필요한 코드로 보임)
- 경계 조건 오류 때문에 버그도 많음

## 둘째, 고쳐보자

- 코드를 고칠 때마다 저자는 JCommon 단위 테스트와 저자가 작성한 단위 테스트를 실행함
- 주석에 있는 법적인 정보는 남기고, 변경 이력은 없애기 (git 과 같은 도구 사용하기 때문에 필요 없음)
- 주석
    - Javadoc이 모든 주석을 `<pre>`로 표현하면, 소스 코드와 문서에 주석이 동일한 모양새로 표현되어 좋음
    - 불필요한 주석은 잘못된 정보가 쌓이기 좋은 곳이므로 제거
    - 변수 이름만으로 의미가 확실한 코드에 있는 주석은 삭제
- `static final` 상수 모임인 `MonthConstants`는 enum으로 정의하고, 이 `enum class`를 상속하도록 수정
- 특정 클래스(`SpreadsheedDate`)에서만 쓰이는 변수는 클래스 안으로 집어 넣기
    - 단, 이 변수가 특정 구현에 의존하지 않는다면, 클래스 위치와 가깝게 옮기기 (내부로 넣지 않음)
- 일반적으로, 부모 클래스는 자식 클래스를 몰라야 함
    - 추상 클래스 사용자가 구현 정보를 알아야 한다는 딜레마..!가 발생했음 → ABSTRACT FACTORY 패턴을 적용하여 해결
- 추상 메서드로 위임하는 정적 메서드는 SINGLETON, DECORATOR, ABSTRACT FACTORY 패턴 조합을 사용함
- 어디에서도 쓰지 않는 변수 (코드) 제거
- 미적인 변경도 추가
    - 예를 들어, if문 두 번 나오는 것을 `||` (or 연산자)를 써서 하나로 만듦
- 일반적으로 메서드 인수로 플래그는 바람직하지 못함
- 함수를 단순화하고 좀 더 서술적인 표현으로 수정
- 메서드의 원래 의도를 잘 반영하는 이름으로 변경
- 테스트 케이스 외에 호출하지 않는 메서드는 … 당연히 둘다 제거
- 정리 해보자면..
    - 처음에 나오는 주석은 너무 오래되었고, 간단하게 고치고 개선함
    - enum을 모두 독자적인 소스 파일로 옮김
    - 정적 변수와 정적 메서드를 `DateUtil` 이라는 새 클래스로 옮김
    - 일부 추상 메서드를 `DayDate` (즉, SerialDate) 로 끌어올림
    - `Month.make`를 `Month.fromInt` 로 변경. 다른 enum도 똑같이 변경함. 또한, 모든 enum에 `toInt()` 접근자를 생성하고 `index` 필드를 `private`로 정의
    - `plusYears`와 `plusMonths`에 중복을 `LastDayOfMonth`라는 새 메서드 만들어 제거함. 새 메서드가 좀 더 명확해짐
    - 소스 이곳저곳에 쓰이는 숫자 `1` 을 없앰. `Month.JANUARY.toInt()` 나 `Day.SUNDAY.toInt()`로 적절히 변경
- 리팩토링 후 코드 커버리지가 떨어짐. 클래스 크기가 작아져 테스트하지 않은 코드의 비중이 커졌기 때문

## 결론

- 코드가 명확해졌기 때문에, 좀 더 코드를 이해하기 쉬워지고, 더 쉽게 개선될 수 있음

# 17. 냄새와 휴리스틱

## 주석

### C1: 부적절한 정보

- 일반적으로 작성자, 최종 수정일, SPR (Software Problem Report) 번호 등과 같은 메타 정보만 주석으로 넣기
- 주석은 코드와 설계에 기술적인 설명을 부연하는 수단
- 다른 시스템에 저장할 정보는 주석으로 적절하지 못함 (소스 관리 시스템, 버그 추적 시스템 등)

### C2: 쓸모 없는 주석

- 쓸모 없는 주석 : 오래된 주석, 엉뚱한 주석, 잘못된 주석
- 주석은 빨리 낡고, 쓸모 없는 주석은 코드와 무관하게 따로 놀고 코드를 그릇된 방향으로 이끔

### C3: 중복된 주석

- 주석은 코드 만으로 다하지 못하는 설명을 부연 설명할 때 사용하기

### C4: 성의 없는 주석

- 작성할 가치가 있는 주석은 잘 작성하기
- 단어를 신중하게 선택. 문법과 구두점을 바르게 하기. 주절대지 않기. 당연한 소리 반복하지 않기. 간결하고 명료하게 작성하기

### C5: 주석 처리된 코드

- 읽는 사람을 헷갈리게 만듦 (얼마나 오래된 코드인지, 중요한 코드인지 알 길이 없음)
- 소스 코드 관리 시스템 이용한다면, 주석으로 처리된 코드는 즉각 지우기

## 환경

### E1: 여러 단계로 빌드해야 한다

- 빌드는 간단히 한 단계로 끝나야 함 (한 명령어로 빌드 할 수 있어야 함)
- 이것 저것 따로 체크 아웃 하고, 명령이나 스크립트를 잇달아 실행해 각 요소를 따로 빌드할 필요가 없어야 함

### E2: 여러 단계로 테스트해야 한다

- 모든 단위 테스트는 한 명령으로 돌려야 함

## 함수

### F1: 너무 많은 인수

- 인수 개수는 작을수록 좋음
- 4개 이상은 그 가치가 아주 의심스러우므로 최대한 피하기

### F2: 출력 인수

- 함수에서 무언가의 상태를 변경해야 한다면, 출력 인수를 쓰지 말고 함수가 속한 객체의 상태를 변경하기
- 56p 예제
    - 출력 인수로 사용하라고 설계한 변수가 바로 `this`
    
    ```tsx
    // Bad
    const appendFooter = (report: string): void => { ... };
    appendFooter(s); // s: 출력 인수
    
    // Good
    report.appendFooter();
    ```
    

### F3: 플래그 인수

- boolean 인수는 함수가 여러 기능을 수행한다는 의미이므로 피하는 것이 좋음

### F4: 죽은 함수

- 아무도 호출하지 않는 함수는 삭제하기
- 죽은 코드는 낭비
- 소스 코드 관리 시스템이 모두 기억하므로 걱정할 필요 없음

## 일반

### G1: 한 소스 파일에 여러 언어를 사용한다

- 이상적으로는 소스 파일 하나에 언어 하나만 사용하는 것

### G2: 당연한 동작을 구현하지 않는다

- 함수나 클래스는 다른 사람이 당연하게 여길 만한 동작과 기능을 제공해야 함

### G3: 경계를 올바로 처리하지 않는다

- 모든 경계 조건을 찾아내고, 그것의 테스트 케이스를 작성하라 (직관에 의존하지 않기)

### G4: 안전 절차 무시

- 안전 절차를 무시하면 위험함
    - serialVersionUID 를 직접 제어하는 경우 위험함
    - 컴파일러 경고를 무시하면 빌드는 쉽지만 끝없는 디버깅에 시달릴 수 있음
    - 실패하는 테스트 케이스를 제껴두면 위험함

### G5: 중복

- 똑같은 코드가 여러 번 나오는 경우, 간단한 함수로 교체하기
- 여러 모듈에서 똑같은 조건을 반복하여 확인하는 중복은 다형성으로 대체하기
- 디자인 패턴 대다수는 중복을 제거하는 것

### G6: 추상화 수준이 올바르지 못하다

- 추상화는 저차원 (상세 개념, 파생 클래스)에서 고차원 (일반 개념, 추상 클래스)을 분리함

### G7: 기초 클래스가 파생 클래스에 의존한다

- 기초 클래스와 파생 클래스를 분리해 독립성을 보장할 수 있음
- 부모 클래스(기초 클래스)는 구현 정보(파생 클래스)를 몰라야 함
- 기초와 파생 클래스를 다른 JAR 파일로 배포하여 독립적인 개별 컴포넌트 단위로 시스템을 배치 할 수 있음
    - 컴포넌트 변경 시 해당 컴포넌트만 다시 배치하면 됨
    - 변경이 시스템에 미치는 영향이 작아져 시스템 유지보수에 도움됨
- (예외 e.g.) 간혹 파생 클래스 개수가 확실히 고정되어 있따면 기초 클래스에서 파생 클래스를 선택하는 코드가 있음
    - FSM (Finite State Machine) : 기초 클래스와 파생 클래스가 밀접하며 언제나 같은 JAR 파일에 배포함

### G8: 과도한 정보

- 잘 정의된 인터페이스는 많은 함수를 제공하지 않음 (작아도 많은 동작이 가능함) → 결합도(coupling)가 낮음
    - 반면, 부실한 인터페이스는 반드시 호출해야 하는 온갖 함수를 제공하여, 결합도가 높음
- 클래스나 모듈 인터페이스에 노출할 함수를 제한하기
    - 자료, 유틸리티 함수, 상수, 임시 변수를 숨기기
    - 메서드나 인스턴스 변수가 많은 클래스는 피하기

### G9: 죽은 코드

- 죽은 코드 == 실행되지 않는 코드
    - 불가능한 조건을 확인하는 if문
    - thorw가 없는 try/catch 블록
- 죽은 코드 발견하면 제거하라

### G10: 수직 분리

- 변수와 함수는 사용되는 위치에 가깝게 정의하기
- 지역 변수는 처음으로 사용하기 직전에 선언하며 수직으로 가까운 곳에 배치하기
- 비공개 함수는 처음으로 호출한 직후에 정의하기 (조금 아래로 내려가면 보이도록)

### G11: 일관성 부족

- 일관성은 코드를 읽고 수정하기 쉽게 도움
- 어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 일관되게 구현하기

### G12: 잡동사니

- 소스 파일은 언제나 깔끔하게 정리하기 (잡동사니 제거)
    - 죽은 코드, 정보를 제공하지 않는 주석 등

### G13: 인위적 결합

- 인위적인 결합은 직접적인 상호작용이 없는 두 모듈 사이에서 발생
- 뚜렷한 목적 없이 변수, 상수, 함수를 편하고 잘못된 위치에 넣어버린 결과

### G14: 기능 욕심

- 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안 됨 (범위를 욕심내지 않기)

### G15: 선택자 인수

- boolean 인수나, enum, int 등 함수 동작을 제어하려는 인수는 바람직하지 않음
- 인수를 넘겨 동작을 선택하는 대신 새로운 함수를 만드는 편이 좋음

### G16: 모호한 의도

- 코드 짤 때 의도를 최대한 분명히 밝히기
- 행을 바꾸지 않고 표현한 수식, 헝가리언 표기법, 매직 번호 등 모두 저자의 의도를 흐림

### G17: 잘못 지운 책임

- 코드는 독자가 자연스럽게 기대할 위치에 배치 (최소 놀람의 원칙)
    - e.g. PI 상수는 삼각함수 선언 클래스에 넣기
- 함수명을 잘 짓기

### G18: 부적절한 static 함수

- 특정 인스턴스와 관련된 기능이 아닌 경우만 static 붙이기
- 일반적으로 static 함수보다 인스턴스 함수가 더 좋음
    - 조금이라도 의심스럽다면 인스턴스 함수로 정의하기
    - static 함수로 정의할 경우 재정의할 가능성이 없는지 꼼꼼히 확인하기

### G19: 서술적 변수

- 프로그램 가독성을 높이는 가장 효과적인 방법 중 하나는 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 것
    
    ```tsx
    const match = pattern.matcher(line);
    if (match.find()) {
    	const key: string = match.group(1) as string;
    	const value: unknown = match.group(2);
    	headers.put(key, value);
    }
    ```
    

### G20: 이름과 기능이 일치하는 함수

### G21: 알고리즘을 이해하라

### G22: 논리적 의존성은 물리적으로 드러내라

### G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라

### G24: 표준 표기법을 따르라

### G25: 매직 숫자는 명명된 상수로 교체하라

### G26: 정확하라

### G27: 관례보다 구조를 사용하라

### G28: 조건을 캡슐화하라

### G29: 부정 조건은 피하라

### G30: 함수는 한 가지만 해야 한다

### G31: 숨겨진 시각적인 결합

### G32: 일관성을 유지하라

### G33: 경계 조건을 캡슐화하라

### G34: 함수는 추상화 수준을 한 단계만 내려가야 한다

### G35: 설정 정보는 최상위 단계에 둬라

### G36: 추이적 탐색을 피하라

## 자바

### J1: 긴 import 목록을 피하고 와일드카드를 사용하라

- 패키지에서 클래스 둘 이상 사용한다면 와일드카드를 사용하여 패키지 전체 가져오기
    
    ```tsx
    import package.*;
    ```
    
- 와일드 카드는 때로 이름 충돌이나 모호성을 초래하기도 함 (자주 발생하지 않음)
- 단순히 검색 경로에 패키지를 추가한 것이므로 모듈 간에 결합성을 낮출 수 있음

### J2: 상수는 상속하지 않는다

### J3: 상수 대 Enum

## 이름

### N1: 서술적인 이름을 사용하라

### N2: 적절한 추상화 수준에서 이름을 선택하라

### N3: 가능하다면 표준 명명법을 사용하라

### N4: 명확한 이름

### N5: 긴 범위는 긴 이름을 사용하라

### N6: 인코딩을 피하라

### N7: 이름으로 부수 효과를 설명하라

## 테스트

### T1: 불충분한 테스트

- 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 함
- 테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있는 경우 그 테스트는 불완전

### T2: 커버리지 도구를 사용하라!

- 커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기 쉬워짐

### T3: 사소한 테스트를 건너뛰지 마라

### T4: 무시한 테스트는 모호함을 뜻한다

### T5: 경계 조건을 테스트하라

### T6: 버그 주변은 철저히 테스트하라

### T7: 실패 패턴을 살펴라

### T8: 테스트 커버리지 패턴을 살펴라

### T9: 테스트는 빨라야 한다

- 느린 테스트 케이스는 실행하지 않게 되므로, 최대한 빠르게 돌아가도록 노력해야 함